<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIMULADOR FODA - Tudo em um arquivo</title>
    <style>
        /* ZERA TUDO */
        * { margin: 0; padding: 0; border: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
        
        /* CANVAS OCUPA TUDO */
        #game { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100vw; 
            height: 100vh; 
            z-index: 1; 
        }
        
        /* CONTROLES GRANDES PRA CELULAR */
        .btn { 
            position: fixed; 
            width: 80px; 
            height: 80px; 
            background: rgba(255,255,255,0.2); 
            border: 3px solid rgba(255,255,255,0.5); 
            border-radius: 50%; 
            color: white; 
            font-size: 32px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            z-index: 100; 
            user-select: none; 
        }
        #esq { bottom: 100px; left: 30px; }
        #dir { bottom: 100px; right: 30px; }
        #acel { bottom: 30px; right: 120px; background: rgba(0,255,0,0.3); }
        #freio { bottom: 30px; right: 30px; background: rgba(255,0,0,0.3); }
        
        /* INFOS NA TELA */
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #0f0;
            z-index: 100;
        }
    </style>
</head>
<body>
    <!-- O JOGO VAI AQUI -->
    <canvas id="game"></canvas>
    
    <!-- CONTROLES -->
    <div class="btn" id="esq">‚Üê</div>
    <div class="btn" id="dir">‚Üí</div>
    <div class="btn" id="acel">‚Üë</div>
    <div class="btn" id="freio">‚Üì</div>
    
    <!-- INFORMA√á√ïES -->
    <div id="info">
        <div>üöó SIMULADOR 3D</div>
        <div>VEL: <span id="vel">0</span> km/h</div>
        <div style="color:#0f0">‚úÖ GR√ÅFICOS ATIVOS</div>
    </div>

    <script>
        // ============================================
        // TUDO AQUI DENTRO - SEM DEPEND√äNCIAS EXTERNAS
        // ============================================
        
        console.log("üî• INICIANDO SIMULADOR FODA");
        
        // 1. TRIPA DO THREE.JS EMBUTIDA (mini vers√£o)
        const ThreeJS = {
            // Matrizes e vetores b√°sicos
            Vector3: class { constructor(x=0,y=0,z=0) { this.x=x; this.y=y; this.z=z; } },
            Matrix4: class { constructor() { this.elements = new Float32Array(16); } },
            
            // Cena simples
            Scene: class { 
                constructor() { 
                    this.children = []; 
                    this.background = null; 
                } 
                add(obj) { this.children.push(obj); }
            },
            
            // C√¢mera
            PerspectiveCamera: class {
                constructor(fov=75, aspect=1, near=0.1, far=1000) {
                    this.fov = fov;
                    this.aspect = aspect;
                    this.near = near;
                    this.far = far;
                    this.position = { x:0, y:5, z:10 };
                    this.rotation = { x:0, y:0, z:0 };
                    this.updateProjectionMatrix = () => {};
                }
            },
            
            // Renderizador WebGL PURO (sem three.js)
            WebGLRenderer: class {
                constructor(config) {
                    this.canvas = config.canvas;
                    this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                    this.setSize(window.innerWidth, window.innerHeight);
                    
                    // Shader b√°sico de v√©rtices
                    this.vertexShader = `
                        attribute vec3 position;
                        attribute vec3 color;
                        varying vec3 vColor;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        void main() {
                            vColor = color;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `;
                    
                    // Shader b√°sico de fragmentos
                    this.fragmentShader = `
                        precision mediump float;
                        varying vec3 vColor;
                        void main() {
                            gl_FragColor = vec4(vColor, 1.0);
                        }
                    `;
                    
                    // Compilar shaders
                    this.program = this.createProgram(this.vertexShader, this.fragmentShader);
                    this.gl.useProgram(this.program);
                    
                    // Configurar WebGL b√°sico
                    this.gl.clearColor(0.0, 0.5, 1.0, 1.0); // C√©u azul
                    this.gl.enable(this.gl.DEPTH_TEST);
                }
                
                createProgram(vs, fs) {
                    const program = this.gl.createProgram();
                    const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vs);
                    const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fs);
                    
                    this.gl.attachShader(program, vertexShader);
                    this.gl.attachShader(program, fragmentShader);
                    this.gl.linkProgram(program);
                    
                    return program;
                }
                
                createShader(type, source) {
                    const shader = this.gl.createShader(type);
                    this.gl.shaderSource(shader, source);
                    this.gl.compileShader(shader);
                    return shader;
                }
                
                setSize(w, h) {
                    this.canvas.width = w;
                    this.canvas.height = h;
                    this.gl.viewport(0, 0, w, h);
                }
                
                render(scene, camera) {
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                    // Aqui renderizaria os objetos
                }
            }
        };
        
        // 2. CRIAR CUBO 3D SIMPLES (prova que WebGL funciona)
        function criarCubo() {
            const canvas = document.getElementById('game');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                alert("SEU CELULAR N√ÉO SUPORTA WEBGL! Usa Chrome, porra.");
                return;
            }
            
            // Configura√ß√£o b√°sica WebGL
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.0, 0.5, 1.0, 1.0); // C√©u azul
            gl.enable(gl.DEPTH_TEST);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // SHADERS EM STRING (tudo dentro do HTML)
            const vsSource = `
                attribute vec4 aVertexPosition;
                attribute vec4 aVertexColor;
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                varying lowp vec4 vColor;
                void main(void) {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                    vColor = aVertexColor;
                }
            `;
            
            const fsSource = `
                varying lowp vec4 vColor;
                void main(void) {
                    gl_FragColor = vColor;
                }
            `;
            
            // Compilar shaders
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vsSource);
            gl.compileShader(vertexShader);
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fsSource);
            gl.compileShader(fragmentShader);
            
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            
            // Posi√ß√µes do cubo (8 v√©rtices)
            const vertices = [
                // Frente
                -1.0, -1.0,  1.0,
                 1.0, -1.0,  1.0,
                 1.0,  1.0,  1.0,
                -1.0,  1.0,  1.0,
                // Tr√°s
                -1.0, -1.0, -1.0,
                -1.0,  1.0, -1.0,
                 1.0,  1.0, -1.0,
                 1.0, -1.0, -1.0,
            ];
            
            // Cores (RGB)
            const colors = [
                1.0, 0.0, 0.0, 1.0,    // Vermelho
                0.0, 1.0, 0.0, 1.0,    // Verde
                0.0, 0.0, 1.0, 1.0,    // Azul
                1.0, 1.0, 0.0, 1.0,    // Amarelo
                1.0, 0.0, 1.0, 1.0,    // Magenta
                0.0, 1.0, 1.0, 1.0,    // Ciano
                1.0, 0.5, 0.0, 1.0,    // Laranja
                0.5, 0.0, 1.0, 1.0,    // Roxo
            ];
            
            // √çndices (12 tri√¢ngulos)
            const indices = [
                0, 1, 2,  0, 2, 3,    // Frente
                4, 5, 6,  4, 6, 7,    // Tr√°s
                4, 0, 3,  4, 3, 5,    // Esquerda
                1, 7, 6,  1, 6, 2,    // Direita
                3, 2, 6,  3, 6, 5,    // Topo
                4, 7, 1,  4, 1, 0,    // Fundo
            ];
            
            // Buffers
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            // Matriz de proje√ß√£o
            const projectionMatrix = new Float32Array(16);
            const fov = 45 * Math.PI / 180;
            const aspect = canvas.width / canvas.height;
            const zNear = 0.1;
            const zFar = 100.0;
            
            // Matriz de proje√ß√£o perspectiva
            const f = 1.0 / Math.tan(fov / 2);
            projectionMatrix[0] = f / aspect;
            projectionMatrix[5] = f;
            projectionMatrix[10] = (zFar + zNear) / (zNear - zFar);
            projectionMatrix[11] = -1;
            projectionMatrix[14] = (2 * zFar * zNear) / (zNear - zFar);
            
            // Matriz de modelo/vis√£o
            const modelViewMatrix = new Float32Array(16);
            
            // ANIMA√á√ÉO DO CUBO
            let rotation = 0;
            
            function render() {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                rotation += 0.01;
                
                // Matriz de rota√ß√£o
                modelViewMatrix[0] = Math.cos(rotation);
                modelViewMatrix[2] = Math.sin(rotation);
                modelViewMatrix[8] = -Math.sin(rotation);
                modelViewMatrix[10] = Math.cos(rotation);
                modelViewMatrix[5] = 1;
                modelViewMatrix[15] = 1;
                
                // Transla√ß√£o (afasta o cubo)
                modelViewMatrix[14] = -6;
                
                // Usar programa
                gl.useProgram(shaderProgram);
                
                // Atributos
                const positionAttrib = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
                gl.enableVertexAttribArray(positionAttrib);
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.vertexAttribPointer(positionAttrib, 3, gl.FLOAT, false, 0, 0);
                
                const colorAttrib = gl.getAttribLocation(shaderProgram, 'aVertexColor');
                gl.enableVertexAttribArray(colorAttrib);
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.vertexAttribPointer(colorAttrib, 4, gl.FLOAT, false, 0, 0);
                
                // Uniformes
                const projMatrixLoc = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
                gl.uniformMatrix4fv(projMatrixLoc, false, projectionMatrix);
                
                const mvMatrixLoc = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');
                gl.uniformMatrix4fv(mvMatrixLoc, false, modelViewMatrix);
                
                // Desenhar
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
                
                requestAnimationFrame(render);
            }
            
            // INICIAR
            render();
            console.log("‚úÖ WEBGL FUNCIONANDO - Cubo 3D girando!");
            document.getElementById('info').innerHTML += "<div style='color:#0f0'>üéÆ CONTROLES ATIVOS</div>";
        }
        
        // 3. CONTROLES SIMPLES (s√≥ pra testar)
        let velocidade = 0;
        let acelerando = false;
        
        document.getElementById('acel').addEventListener('touchstart', () => {
            acelerando = true;
            document.getElementById('acel').style.background = 'rgba(0,255,0,0.6)';
        });
        
        document.getElementById('acel').addEventListener('touchend', () => {
            acelerando = false;
            document.getElementById('acel').style.background = 'rgba(0,255,0,0.3)';
        });
        
        // Atualizar velocidade
        setInterval(() => {
            if (acelerando) {
                velocidade += 1;
                if (velocidade > 200) velocidade = 200;
            } else {
                velocidade *= 0.95;
            }
            document.getElementById('vel').textContent = Math.floor(velocidade);
        }, 100);
        
        // 4. INICIAR TUDO QUANDO CARREGAR
        window.addEventListener('load', () => {
            console.log("üì± CELULAR PRONTO");
            criarCubo();
            
            // Tamanho correto do canvas
            const canvas = document.getElementById('game');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Evento de resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        });
        
        // 5. DETECTAR ERROS
        window.addEventListener('error', (e) => {
            console.error("ERRO:", e.message);
            document.getElementById('info').innerHTML = 
                `<div style='color:red'>‚ùå ERRO: ${e.message}</div>` +
                `<div>Tenta no Chrome, porra</div>`;
        });
        
        // LOG INICIAL
        console.log("üî• SIMULADOR CARREGADO - Tudo em um HTML s√≥");
        console.log("üëâ Se aparecer um cubo colorido girando, WEBGL funciona!");
        console.log("üëâ Use os bot√µes grandes pra acelerar");
        
    </script>
</body>
</html>
