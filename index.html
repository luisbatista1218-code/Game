<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Carro Profissional - Gráficos Reais</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.19.0/dist/cannon-es.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: Arial, sans-serif; 
            background: #000;
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        /* Painel profissional */
        #dashboard {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            min-width: 400px;
            display: flex;
            gap: 30px;
            backdrop-filter: blur(10px);
        }
        .gauge {
            color: white;
            text-align: center;
        }
        .gauge-label {
            font-size: 12px;
            color: #00ff88;
            margin-bottom: 5px;
        }
        .gauge-value {
            font-size: 28px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        /* Controles touch */
        #controls {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: auto;
        }
        .control-zone {
            position: absolute;
            opacity: 0.3;
        }
        #steer-zone {
            left: 0;
            width: 40%;
            height: 100%;
            background: blue;
        }
        #pedals-zone {
            right: 0;
            width: 40%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        #accelerator {
            flex: 1;
            background: green;
            margin-bottom: 10px;
        }
        #brake {
            flex: 1;
            background: red;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="dashboard">
                <div class="gauge">
                    <div class="gauge-label">VELOCIDADE</div>
                    <div class="gauge-value" id="speed">0 <span style="font-size: 14px">km/h</span></div>
                </div>
                <div class="gauge">
                    <div class="gauge-label">RPM</div>
                    <div class="gauge-value" id="rpm">0</div>
                </div>
                <div class="gauge">
                    <div class="gauge-label">MARCHA</div>
                    <div class="gauge-value" id="gear">N</div>
                </div>
            </div>
        </div>
        <div id="controls">
            <div class="control-zone" id="steer-zone"></div>
            <div class="control-zone" id="pedals-zone">
                <div class="control-zone" id="accelerator"></div>
                <div class="control-zone" id="brake"></div>
            </div>
        </div>
    </div>

    <script>
        // ========== CONFIGURAÇÃO ==========
        let scene, camera, renderer, world;
        let carBody, carModel;
        let steerAngle = 0;
        let engineForce = 0;
        let brakeForce = 0;
        let speed = 0;
        let rpm = 0;
        
        // ========== INICIALIZAR THREE.JS ==========
        function init() {
            // Cena
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 100, 2000);
            
            // Câmera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(0, 3, 8);
            
            // Renderizador
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            // Iluminação profissional
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(100, 500, 100);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -200;
            sunLight.shadow.camera.right = 200;
            sunLight.shadow.camera.top = 200;
            sunLight.shadow.camera.bottom = -200;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            scene.add(sunLight);
            
            // Céu realista
            const skyColor = 0x87CEEB;
            const groundColor = 0x228B22;
            const intensity = 1;
            const hemisphereLight = new THREE.HemisphereLight(skyColor, groundColor, intensity);
            scene.add(hemisphereLight);
            
            // Criar cenário
            createEnvironment();
            
            // Criar carro
            createCar();
            
            // Física
            initPhysics();
            
            // Controles
            setupControls();
            
            // Resize handler
            window.addEventListener('resize', onWindowResize);
            
            // Iniciar loop
            animate();
        }
        
        // ========== CENÁRIO REALISTA ==========
        function createEnvironment() {
            // Textura do solo (imagem real de asfalto)
            const textureLoader = new THREE.TextureLoader();
            const groundTexture = textureLoader.load('https://images.unsplash.com/photo-1544984243-ec57ea16fe25?auto=format&fit=crop&w=1200');
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(50, 50);
            
            // Terreno
            const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: groundTexture,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Pista com textura real
            const roadTexture = textureLoader.load('https://images.unsplash.com/photo-1548357262-8d77b5f7ed78?auto=format&fit=crop&w=1200');
            roadTexture.wrapS = roadTexture.wrapT = THREE.RepeatWrapping;
            roadTexture.repeat.set(100, 1);
            
            const roadGeometry = new THREE.PlaneGeometry(20, 2000);
            const roadMaterial = new THREE.MeshStandardMaterial({
                map: roadTexture,
                roughness: 0.7,
                metalness: 0.1
            });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.01;
            road.receiveShadow = true;
            scene.add(road);
            
            // Linhas da pista
            const lineGeometry = new THREE.PlaneGeometry(0.5, 2000);
            const lineMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF00,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.5
            });
            
            // Linha central
            const centerLine = new THREE.Mesh(lineGeometry, lineMaterial);
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.y = 0.02;
            scene.add(centerLine);
            
            // Linhas laterais
            const leftLine = centerLine.clone();
            leftLine.position.x = -7.5;
            scene.add(leftLine);
            
            const rightLine = centerLine.clone();
            rightLine.position.x = 7.5;
            scene.add(rightLine);
            
            // Criar montanhas ao redor
            createMountains();
            
            // Árvores e vegetação
            createVegetation();
            
            // Céu
            const skyboxLoader = new THREE.CubeTextureLoader();
            const skyboxTexture = skyboxLoader.load([
                'https://threejs.org/examples/textures/cube/skybox/px.jpg',
                'https://threejs.org/examples/textures/cube/skybox/nx.jpg',
                'https://threejs.org/examples/textures/cube/skybox/py.jpg',
                'https://threejs.org/examples/textures/cube/skybox/ny.jpg',
                'https://threejs.org/examples/textures/cube/skybox/pz.jpg',
                'https://threejs.org/examples/textures/cube/skybox/nz.jpg'
            ]);
            scene.background = skyboxTexture;
        }
        
        function createMountains() {
            const mountainGeometry = new THREE.ConeGeometry(100, 300, 32);
            const mountainMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.9
            });
            
            // Várias montanhas ao redor
            const positions = [
                [-500, 0, -500],
                [500, 0, -500],
                [-500, 0, 500],
                [500, 0, 500],
                [-800, 0, 0],
                [800, 0, 0]
            ];
            
            positions.forEach(pos => {
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountain.position.set(pos[0], pos[1], pos[2]);
                mountain.castShadow = true;
                scene.add(mountain);
            });
        }
        
        function createVegetation() {
            // Textura de árvore
            const treeTexture = new THREE.TextureLoader().load(
                'https://threejs.org/examples/textures/sprites/tree.png'
            );
            
            // Criar várias árvores
            for (let i = 0; i < 100; i++) {
                const treeMaterial = new THREE.SpriteMaterial({
                    map: treeTexture,
                    color: 0x228B22
                });
                const tree = new THREE.Sprite(treeMaterial);
                tree.position.set(
                    (Math.random() - 0.5) * 800,
                    50,
                    (Math.random() - 0.5) * 800
                );
                tree.scale.set(50, 50, 1);
                scene.add(tree);
            }
        }
        
        // ========== CARRO 3D REALISTA ==========
        function createCar() {
            // Criar grupo do carro
            carModel = new THREE.Group();
            
            // Carroceria principal
            const bodyGeometry = new THREE.BoxGeometry(2, 1, 4);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                roughness: 0.4,
                metalness: 0.8,
                envMapIntensity: 1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            carModel.add(body);
            
            // Vidros
            const glassGeometry = new THREE.BoxGeometry(1.8, 0.8, 1.5);
            const glassMaterial = new THREE.MeshStandardMaterial({
                color: 0x88CCFF,
                transparent: true,
                opacity: 0.3,
                roughness: 0.1,
                metalness: 1
            });
            const glass = new THREE.Mesh(glassGeometry, glassMaterial);
            glass.position.y = 0.6;
            glass.position.z = 0.5;
            carModel.add(glass);
            
            // Rodas
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x222222,
                roughness: 0.7,
                metalness: 0.3
            });
            
            const wheelPositions = [
                [-0.8, -0.2, 1.2],  // Frente esquerda
                [0.8, -0.2, 1.2],   // Frente direita
                [-0.8, -0.2, -1.2], // Traseira esquerda
                [0.8, -0.2, -1.2]   // Traseira direita
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                carModel.add(wheel);
            });
            
            // Faróis
            const headlightGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const headlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFAA,
                emissive: 0xFFFFAA,
                emissiveIntensity: 2
            });
            
            const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            leftHeadlight.position.set(-0.7, 0.2, 1.9);
            carModel.add(leftHeadlight);
            
            const rightHeadlight = leftHeadlight.clone();
            rightHeadlight.position.set(0.7, 0.2, 1.9);
            carModel.add(rightHeadlight);
            
            scene.add(carModel);
            carModel.position.y = 1;
            
            console.log('Carro 3D criado com gráficos reais!');
        }
        
        // ========== FÍSICA PROFISSIONAL ==========
        function initPhysics() {
            // Inicializar mundo de física
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.allowSleep = true;
            
            // Criar chão físico
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: groundShape
            });
            groundBody.quaternion.setFromAxisAngle(
                new CANNON.Vec3(1, 0, 0),
                -Math.PI / 2
            );
            world.addBody(groundBody);
            
            // Criar corpo do carro físico
            const carShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
            carBody = new CANNON.Body({
                mass: 1500,
                shape: carShape,
                linearDamping: 0.1,
                angularDamping: 0.3
            });
            carBody.position.set(0, 2, 0);
            world.addBody(carBody);
        }
        
        // ========== CONTROLES TOUCH ==========
        function setupControls() {
            const steerZone = document.getElementById('steer-zone');
            const accelerator = document.getElementById('accelerator');
            const brake = document.getElementById('brake');
            
            let steerStartX = 0;
            let isSteering = false;
            
            // Direção
            steerZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isSteering = true;
                steerStartX = e.touches[0].clientX;
            });
            
            steerZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isSteering) {
                    const deltaX = e.touches[0].clientX - steerStartX;
                    steerAngle = (deltaX / window.innerWidth) * Math.PI / 4;
                    steerAngle = Math.max(-Math.PI/4, Math.min(Math.PI/4, steerAngle));
                }
            });
            
            steerZone.addEventListener('touchend', () => {
                isSteering = false;
                steerAngle = 0;
            });
            
            // Acelerador
            accelerator.addEventListener('touchstart', () => {
                engineForce = 500;
                accelerator.style.opacity = '0.6';
            });
            
            accelerator.addEventListener('touchend', () => {
                engineForce = 0;
                accelerator.style.opacity = '0.3';
            });
            
            // Freio
            brake.addEventListener('touchstart', () => {
                brakeForce = 1000;
                brake.style.opacity = '0.6';
            });
            
            brake.addEventListener('touchend', () => {
                brakeForce = 0;
                brake.style.opacity = '0.3';
            });
            
            // Controles de teclado para teste no PC
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'ArrowUp': engineForce = 500; break;
                    case 'ArrowDown': brakeForce = 1000; break;
                    case 'ArrowLeft': steerAngle = Math.PI/4; break;
                    case 'ArrowRight': steerAngle = -Math.PI/4; break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                switch(e.key) {
                    case 'ArrowUp': engineForce = 0; break;
                    case 'ArrowDown': brakeForce = 0; break;
                    case 'ArrowLeft':
                    case 'ArrowRight': steerAngle = 0; break;
                }
            });
        }
        
        // ========== ATUALIZAR FÍSICA ==========
        function updatePhysics(deltaTime) {
            // Atualizar mundo de física
            world.step(deltaTime);
            
            // Aplicar forças do motor
            const force = new CANNON.Vec3(
                -Math.sin(carBody.quaternion.y) * engineForce,
                0,
                -Math.cos(carBody.quaternion.y) * engineForce
            );
            carBody.applyForce(force, carBody.position);
            
            // Aplicar força de freio
            if (brakeForce > 0) {
                const brakeForceVec = new CANNON.Vec3(
                    carBody.velocity.x * -brakeForce,
                    0,
                    carBody.velocity.z * -brakeForce
                );
                carBody.applyForce(brakeForceVec, carBody.position);
            }
            
            // Aplicar direção
            carBody.angularVelocity.y = steerAngle * 2;
            
            // Sincronizar modelo 3D com física
            if (carModel && carBody) {
                carModel.position.copy(carBody.position);
                carModel.quaternion.copy(carBody.quaternion);
                
                // Calcular velocidade
                const velocity = carBody.velocity.length();
                speed = Math.abs(velocity * 3.6); // m/s para km/h
                rpm = Math.min(8000, engineForce * 10 + speed * 80);
                
                // Atualizar UI
                document.getElementById('speed').textContent = 
                    Math.floor(speed) + ' km/h';
                document.getElementById('rpm').textContent = 
                    Math.floor(rpm);
                document.getElementById('gear').textContent = 
                    speed < 10 ? 'N' : speed < 30 ? '1' : speed < 60 ? '2' : '3';
            }
        }
        
        // ========== LOOP DE ANIMAÇÃO ==========
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = 1/60; // Física em 60 FPS
            
            // Atualizar física
            updatePhysics(deltaTime);
            
            // Atualizar câmera (seguir carro)
            if (carBody) {
                camera.position.x = carBody.position.x;
                camera.position.z = carBody.position.z + 8;
                camera.position.y = carBody.position.y + 3;
                camera.lookAt(carBody.position.x, carBody.position.y + 1, carBody.position.z);
            }
            
            // Renderizar
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ========== INICIAR TUDO ==========
        init();
    </script>
</body>
</html>
